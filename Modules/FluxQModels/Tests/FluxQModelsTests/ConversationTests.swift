import Testing
import Foundation
@testable import FluxQModels

@Suite("Conversation Tests")
struct ConversationTests {

    @Test("Initialization with all parameters")
    func initWithAllParameters() {
        let date = Date(timeIntervalSince1970: 1700000000)
        let conversation = Conversation(
            id: "conv-001",
            type: .group,
            participantIDs: ["user-001", "user-002", "user-003"],
            lastMessageTimestamp: date,
            unreadCount: 5
        )

        #expect(conversation.id == "conv-001")
        #expect(conversation.type == .group)
        #expect(conversation.participantIDs == ["user-001", "user-002", "user-003"])
        #expect(conversation.lastMessageTimestamp == date)
        #expect(conversation.unreadCount == 5)
    }

    @Test("Default values are applied correctly")
    func defaultValues() {
        let before = Date()
        let conversation = Conversation(
            type: .private,
            participantIDs: ["user-001"]
        )
        let after = Date()

        #expect(!conversation.id.isEmpty)
        #expect(UUID(uuidString: conversation.id) != nil)
        #expect(conversation.unreadCount == 0)
        #expect(conversation.lastMessageTimestamp >= before)
        #expect(conversation.lastMessageTimestamp <= after)
    }

    @Test("Private conversation type")
    func privateType() {
        let conversation = Conversation(
            type: .private,
            participantIDs: ["user-001", "user-002"]
        )

        #expect(conversation.type == .private)
    }

    @Test("Group conversation type")
    func groupType() {
        let conversation = Conversation(
            type: .group,
            participantIDs: ["user-001", "user-002", "user-003"]
        )

        #expect(conversation.type == .group)
    }

    @Test("Empty participants list")
    func emptyParticipants() {
        let conversation = Conversation(
            type: .private,
            participantIDs: []
        )

        #expect(conversation.participantIDs.isEmpty)
        #expect(conversation.participantIDs.count == 0)
    }

    @Test("lastMessageTimestamp stores custom date")
    func lastMessageTimestamp() {
        let specificDate = Date(timeIntervalSince1970: 1609459200)
        let conversation = Conversation(
            type: .private,
            participantIDs: ["user-001"],
            lastMessageTimestamp: specificDate
        )

        #expect(conversation.lastMessageTimestamp == specificDate)
        #expect(conversation.lastMessageTimestamp.timeIntervalSince1970 == 1609459200)
    }

    @Test("unreadCount stores correctly")
    func unreadCount() {
        let conversation = Conversation(
            type: .group,
            participantIDs: ["user-001"],
            unreadCount: 42
        )

        #expect(conversation.unreadCount == 42)
    }

    @Test("ID is auto-generated as UUID string")
    func autoGeneratedID() {
        let conv1 = Conversation(type: .private, participantIDs: ["u1"])
        let conv2 = Conversation(type: .private, participantIDs: ["u1"])

        #expect(conv1.id != conv2.id)
        #expect(UUID(uuidString: conv1.id) != nil)
        #expect(UUID(uuidString: conv2.id) != nil)
    }

    @Test("Multiple participants stored correctly")
    func multipleParticipants() {
        let ids = (1...10).map { "user-\(String(format: "%03d", $0))" }
        let conversation = Conversation(
            type: .group,
            participantIDs: ids
        )

        #expect(conversation.participantIDs.count == 10)
        #expect(conversation.participantIDs.first == "user-001")
        #expect(conversation.participantIDs.last == "user-010")
    }

    @Test("Relationship properties default to nil")
    func relationshipDefaults() {
        let conversation = Conversation(
            type: .private,
            participantIDs: ["user-001"]
        )

        #expect(conversation.participants == nil)
        #expect(conversation.messages == nil)
    }
}

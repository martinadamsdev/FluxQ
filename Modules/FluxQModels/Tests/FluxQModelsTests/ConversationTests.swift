import Testing
import Foundation
@testable import FluxQModels

@Suite("Conversation Tests")
struct ConversationTests {

    @Test("Initialization with all parameters")
    func initWithAllParameters() {
        let date = Date(timeIntervalSince1970: 1700000000)
        let convId = UUID(uuidString: "00000000-0000-0000-0000-000000000001")!
        let pIds = [
            UUID(uuidString: "00000000-0000-0000-0000-000000000010")!,
            UUID(uuidString: "00000000-0000-0000-0000-000000000020")!,
            UUID(uuidString: "00000000-0000-0000-0000-000000000030")!,
        ]
        let conversation = Conversation(
            id: convId,
            type: .group,
            participantIDs: pIds,
            lastMessageTimestamp: date,
            unreadCount: 5
        )

        #expect(conversation.id == convId)
        #expect(conversation.type == .group)
        #expect(conversation.participantIDs == pIds)
        #expect(conversation.lastMessageTimestamp == date)
        #expect(conversation.unreadCount == 5)
    }

    @Test("Default values are applied correctly")
    func defaultValues() {
        let before = Date()
        let conversation = Conversation(
            type: .private,
            participantIDs: [UUID()]
        )
        let after = Date()

        #expect(conversation.unreadCount == 0)
        #expect(conversation.lastMessageTimestamp >= before)
        #expect(conversation.lastMessageTimestamp <= after)
    }

    @Test("Private conversation type")
    func privateType() {
        let conversation = Conversation(
            type: .private,
            participantIDs: [UUID(), UUID()]
        )

        #expect(conversation.type == .private)
    }

    @Test("Group conversation type")
    func groupType() {
        let conversation = Conversation(
            type: .group,
            participantIDs: [UUID(), UUID(), UUID()]
        )

        #expect(conversation.type == .group)
    }

    @Test("Empty participants list")
    func emptyParticipants() {
        let conversation = Conversation(
            type: .private,
            participantIDs: []
        )

        #expect(conversation.participantIDs.isEmpty)
        #expect(conversation.participantIDs.count == 0)
    }

    @Test("lastMessageTimestamp stores custom date")
    func lastMessageTimestamp() {
        let specificDate = Date(timeIntervalSince1970: 1609459200)
        let conversation = Conversation(
            type: .private,
            participantIDs: [UUID()],
            lastMessageTimestamp: specificDate
        )

        #expect(conversation.lastMessageTimestamp == specificDate)
        #expect(conversation.lastMessageTimestamp.timeIntervalSince1970 == 1609459200)
    }

    @Test("unreadCount stores correctly")
    func unreadCount() {
        let conversation = Conversation(
            type: .group,
            participantIDs: [UUID()],
            unreadCount: 42
        )

        #expect(conversation.unreadCount == 42)
    }

    @Test("ID is auto-generated as UUID")
    func autoGeneratedID() {
        let conv1 = Conversation(type: .private, participantIDs: [UUID()])
        let conv2 = Conversation(type: .private, participantIDs: [UUID()])

        #expect(conv1.id != conv2.id)
    }

    @Test("Multiple participants stored correctly")
    func multipleParticipants() {
        let ids = (1...10).map { _ in UUID() }
        let conversation = Conversation(
            type: .group,
            participantIDs: ids
        )

        #expect(conversation.participantIDs.count == 10)
        #expect(conversation.participantIDs.first == ids.first)
        #expect(conversation.participantIDs.last == ids.last)
    }

    @Test("Relationship properties default to nil")
    func relationshipDefaults() {
        let conversation = Conversation(
            type: .private,
            participantIDs: [UUID()]
        )

        #expect(conversation.participants == nil)
        #expect(conversation.messages == nil)
    }
}

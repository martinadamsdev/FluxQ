import Testing
import Foundation
@testable import FluxQModels

@Suite("Message Tests")
struct MessageTests {

    @Test("Initialization with all parameters")
    func initWithAllParameters() {
        let date = Date(timeIntervalSince1970: 1700000000)
        let message = Message(
            id: "msg-001",
            conversationID: "conv-001",
            senderID: "user-001",
            content: "Hello, World!",
            timestamp: date,
            status: .delivered,
            isEncrypted: true
        )

        #expect(message.id == "msg-001")
        #expect(message.conversationID == "conv-001")
        #expect(message.senderID == "user-001")
        #expect(message.content == "Hello, World!")
        #expect(message.timestamp == date)
        #expect(message.status == .delivered)
        #expect(message.isEncrypted == true)
    }

    @Test("Default values are applied correctly")
    func defaultValues() {
        let before = Date()
        let message = Message(
            conversationID: "conv-001",
            senderID: "user-001",
            content: "Test"
        )
        let after = Date()

        #expect(!message.id.isEmpty)
        #expect(message.status == .sending)
        #expect(message.isEncrypted == false)
        #expect(message.timestamp >= before)
        #expect(message.timestamp <= after)
    }

    @Test("ID is auto-generated as UUID string")
    func autoGeneratedID() {
        let msg1 = Message(conversationID: "c1", senderID: "u1", content: "a")
        let msg2 = Message(conversationID: "c1", senderID: "u1", content: "b")

        #expect(msg1.id != msg2.id)
        #expect(UUID(uuidString: msg1.id) != nil)
        #expect(UUID(uuidString: msg2.id) != nil)
    }

    @Test("Timestamp records correctly")
    func timestampRecording() {
        let specificDate = Date(timeIntervalSince1970: 1609459200) // 2021-01-01
        let message = Message(
            conversationID: "conv-001",
            senderID: "user-001",
            content: "New Year",
            timestamp: specificDate
        )

        #expect(message.timestamp == specificDate)
        #expect(message.timestamp.timeIntervalSince1970 == 1609459200)
    }

    @Test("SenderID and conversationID stored correctly")
    func senderAndConversationIDs() {
        let message = Message(
            conversationID: "192.168.1.100:conv",
            senderID: "192.168.1.100:2425",
            content: "Test"
        )

        #expect(message.senderID == "192.168.1.100:2425")
        #expect(message.conversationID == "192.168.1.100:conv")
    }

    @Test("Content supports empty string")
    func emptyContent() {
        let message = Message(
            conversationID: "conv-001",
            senderID: "user-001",
            content: ""
        )

        #expect(message.content == "")
        #expect(message.content.isEmpty)
    }

    @Test("Content supports long text")
    func longContent() {
        let longText = String(repeating: "A", count: 10_000)
        let message = Message(
            conversationID: "conv-001",
            senderID: "user-001",
            content: longText
        )

        #expect(message.content == longText)
        #expect(message.content.count == 10_000)
    }

    @Test("Content supports Unicode and emoji")
    func unicodeAndEmojiContent() {
        let unicodeContent = "Hello \u{1F600} ä½ å¥½ä¸–ç•Œ ã“ã‚“ã«ã¡ã¯ ðŸŽ‰ðŸš€"
        let message = Message(
            conversationID: "conv-001",
            senderID: "user-001",
            content: unicodeContent
        )

        #expect(message.content == unicodeContent)
        #expect(message.content.contains("ðŸŽ‰"))
        #expect(message.content.contains("ä½ å¥½ä¸–ç•Œ"))
    }

    @Test("All MessageStatus values can be assigned")
    func allStatusValues() {
        let statuses: [MessageStatus] = [.sending, .sent, .delivered, .read, .failed]
        for status in statuses {
            let message = Message(
                conversationID: "conv-001",
                senderID: "user-001",
                content: "Test",
                status: status
            )
            #expect(message.status == status)
        }
    }

    @Test("isEncrypted flag works correctly")
    func encryptedFlag() {
        let encrypted = Message(
            conversationID: "conv-001",
            senderID: "user-001",
            content: "Secret",
            isEncrypted: true
        )
        let unencrypted = Message(
            conversationID: "conv-001",
            senderID: "user-001",
            content: "Public",
            isEncrypted: false
        )

        #expect(encrypted.isEncrypted == true)
        #expect(unencrypted.isEncrypted == false)
    }
}

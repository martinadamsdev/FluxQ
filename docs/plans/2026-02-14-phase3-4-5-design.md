# Phase 3/4/5 è®¾è®¡æ–‡æ¡£ï¼šå®Œæ•´è·¨å¹³å°ä½“éªŒ

**è®¾è®¡æ—¥æœŸ**ï¼š2026-02-14
**å®æ–½ç­–ç•¥**ï¼šé¡ºåºå®æ–½ï¼ˆPhase 3 â†’ Phase 4 â†’ Phase 5ï¼‰
**é¢„è®¡æ—¶é—´**ï¼š3.5-4 å‘¨

---

## æ‰§è¡Œæ‘˜è¦

æœ¬è®¾è®¡æ–‡æ¡£æ¶µç›– FluxQ çš„ä¸‰ä¸ªæ ¸å¿ƒå¢å¼ºé˜¶æ®µï¼š

- **Phase 3**ï¼šå±€åŸŸç½‘å‘ç°å¢å¼ºï¼ˆç”¨æˆ·å¤´åƒ + æœç´¢è¿‡æ»¤ + å¿ƒè·³ä¿æ´»ï¼‰
- **Phase 4**ï¼šèŠå¤©ä½“éªŒå¢å¼ºï¼ˆTCP æ¶ˆæ¯ + æ¶ˆæ¯æ’¤å› + è¾“å…¥æç¤º + å¤åˆ¶/è½¬å‘ï¼‰
- **Phase 5**ï¼šå®Œæ•´ watchOS ä½“éªŒï¼ˆWatch Connectivity + ç‹¬ç«‹ç½‘ç»œ + Complication + å¿«é€Ÿå›å¤ï¼‰

### å…³é”®æŠ€æœ¯å†³ç­–

| å†³ç­–ç‚¹ | é€‰æ‹©æ–¹æ¡ˆ |
|--------|----------|
| ç”¨æˆ·å¤´åƒå­˜å‚¨ | æ··åˆï¼šæœ¬åœ°æ–‡ä»¶ + UDP å¹¿æ’­ + CloudKit åŒæ­¥ |
| å¿ƒè·³ä¿æ´»ç­–ç•¥ | èŠ‚èƒ½æ¨¡å¼ï¼šwatchOS 60s/120sï¼ŒiOS åŠ¨æ€ï¼ŒmacOS 30s/60s |
| TCP å®ç°æ–¹å¼ | æ··åˆï¼šUDP ç”¨ Network.frameworkï¼ŒTCP ç”¨ BSD Socket |
| æ¶ˆæ¯æ’¤å›æœºåˆ¶ | æ··åˆï¼š2 åˆ†é’Ÿæ—¶é—´çª—å£ + å®æ—¶ TCP + ç¦»çº¿è¡¥å¿ |
| watchOS ç½‘ç»œæ¨¡å¼ | æ™ºèƒ½é™çº§ï¼šWatch Connectivity ä¼˜å…ˆ + Wi-Fi ç‹¬ç«‹ + GPS ç¦»çº¿ |
| å®æ–½ç­–ç•¥ | æ–¹æ¡ˆ Aï¼šé¡ºåºå®æ–½ï¼ˆä¿å®ˆç¨³å¥ï¼Œ3.5-4 å‘¨ï¼‰ |

---

## Phase 3ï¼šå±€åŸŸç½‘å‘ç°å¢å¼º

**ç›®æ ‡**ï¼šåœ¨ v0.2.0 åŸºç¡€ä¸Šï¼Œå¢åŠ ç”¨æˆ·å¤´åƒã€æœç´¢è¿‡æ»¤å’Œå¿ƒè·³ä¿æ´»æœºåˆ¶ã€‚

### æ¶æ„è®¾è®¡

#### æ¨¡å—æ¶æ„

```
Phase 3 æ¶æ„å±‚æ¬¡ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          DiscoveryView (UI)             â”‚ â† åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ + å¤´åƒæ˜¾ç¤º
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       DiscoveryService (ä¸šåŠ¡å±‚)         â”‚ â† ç”¨æˆ·å‘ç°åè°ƒå™¨
â”‚  â”œâ”€ UDPDiscoveryService                 â”‚ â† UDP å¹¿æ’­æœåŠ¡ï¼ˆå·²æœ‰ï¼‰
â”‚  â”œâ”€ AvatarService (æ–°å¢)                â”‚ â† å¤´åƒç®¡ç†æœåŠ¡
â”‚  â”œâ”€ SearchFilterService (æ–°å¢)          â”‚ â† æœç´¢å’Œè¿‡æ»¤
â”‚  â””â”€ HeartbeatService (æ–°å¢)             â”‚ â† å¿ƒè·³ä¿æ´»
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      IPMsgProtocol (åè®®å±‚)             â”‚ â† åè®®æ‰©å±•
â”‚  â”œâ”€ IPMSG_AVATAR (æ–°å‘½ä»¤)               â”‚ â† å¤´åƒå…ƒæ•°æ®
â”‚  â””â”€ BR_ABSENCE (å¿ƒè·³å‘½ä»¤)               â”‚ â† å·²æœ‰ï¼Œå¢å¼ºä½¿ç”¨
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         FluxQModels (æ•°æ®å±‚)            â”‚
â”‚  â”œâ”€ User (å¢å¼º)                         â”‚ â† æ–°å¢ avatarData, lastSeen
â”‚  â””â”€ DiscoveredUser (å¢å¼º)               â”‚ â† æ–°å¢ avatarHash, isOnline
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“ CloudKit åŒæ­¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   iCloud (User.avatarData åŒæ­¥)         â”‚ â† è·¨è®¾å¤‡åŒæ­¥å¤´åƒ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ä¾èµ–å…³ç³»

- `AvatarService` â†’ `IPMsgProtocol` + `FluxQModels`
- `HeartbeatService` â†’ `UDPDiscoveryService` + `IPMsgProtocol`
- `SearchFilterService` â†’ `FluxQModels` (çº¯é€»è¾‘ï¼Œæ— ä¾èµ–)
- `DiscoveryView` â†’ `DiscoveryService` (å•å‘ä¾èµ–)

### æ ¸å¿ƒç»„ä»¶

#### 1. AvatarService - å¤´åƒç®¡ç†æœåŠ¡

```swift
@MainActor
class AvatarService: ObservableObject {
    // ä¾èµ–
    private let udpService: UDPDiscoveryService
    private let modelContext: ModelContext

    // æœ¬åœ°å¤´åƒç¼“å­˜ï¼ˆå†…å­˜ï¼‰
    @Published private(set) var avatarCache: [String: Data] = [:]

    // è®¾ç½®å½“å‰ç”¨æˆ·å¤´åƒï¼ˆæœ¬åœ° + CloudKit åŒæ­¥ï¼‰
    func setMyAvatar(_ imageData: Data) async throws {
        let user = try getCurrentUser()
        user.avatarData = imageData
        user.avatarHash = imageData.sha256Hash
        try modelContext.save() // è‡ªåŠ¨ CloudKit åŒæ­¥

        // å¹¿æ’­å¤´åƒå…ƒæ•°æ®
        try await broadcastAvatarMetadata()
    }

    // è¯·æ±‚å…¶ä»–ç”¨æˆ·çš„å¤´åƒï¼ˆTCP ä¼ è¾“ï¼‰
    func requestAvatar(userId: String, hash: String) async throws -> Data {
        if let cached = avatarCache[hash] {
            return cached
        }

        // TCP è¯·æ±‚å¤´åƒæ•°æ®
        let avatarData = try await tcpService.requestAvatar(userId: userId)
        avatarCache[hash] = avatarData
        return avatarData
    }

    // UDP å¹¿æ’­å¤´åƒå…ƒæ•°æ®
    private func broadcastAvatarMetadata() async throws {
        let user = try getCurrentUser()
        let command = IPMsgCommand.avatar(hash: user.avatarHash)
        try await udpService.broadcast(command)
    }
}
```

#### 2. HeartbeatService - å¿ƒè·³ä¿æ´»æœåŠ¡

```swift
@MainActor
class HeartbeatService: ObservableObject {
    // å¹³å°å·®å¼‚åŒ–ç­–ç•¥
    private var heartbeatInterval: TimeInterval {
        #if os(watchOS)
        return 60.0  // watchOS: 60 ç§’
        #elseif os(iOS)
        return UIApplication.shared.applicationState == .active ? 30.0 : 60.0
        #else
        return 30.0  // macOS: 30 ç§’
        #endif
    }

    private var timeoutInterval: TimeInterval {
        heartbeatInterval * 2
    }

    // åœ¨çº¿ç”¨æˆ·ç®¡ç†
    @Published private(set) var onlineUsers: [String: Date] = [:]

    // å¯åŠ¨å¿ƒè·³
    func startHeartbeat() {
        Task {
            while !Task.isCancelled {
                try? await sendHeartbeat()
                try? await Task.sleep(for: .seconds(heartbeatInterval))
            }
        }

        // å¯åŠ¨è¶…æ—¶æ£€æµ‹
        startTimeoutMonitor()
    }

    // å‘é€å¿ƒè·³ï¼ˆBR_ABSENCE + æºå¸¦æ’¤å›åˆ—è¡¨ï¼‰
    private func sendHeartbeat() async throws {
        let command = IPMsgCommand.absence(recallList: getRecentRecalls())
        try await udpService.broadcast(command)
    }

    // è¶…æ—¶æ£€æµ‹ï¼ˆæ ‡è®°ç¦»çº¿ç”¨æˆ·ï¼‰
    private func startTimeoutMonitor() {
        Task {
            while !Task.isCancelled {
                let now = Date()
                for (userId, lastSeen) in onlineUsers {
                    if now.timeIntervalSince(lastSeen) > timeoutInterval {
                        markUserOffline(userId)
                    }
                }
                try? await Task.sleep(for: .seconds(10))
            }
        }
    }
}
```

#### 3. SearchFilterService - æœç´¢å’Œè¿‡æ»¤æœåŠ¡

```swift
@MainActor
class SearchFilterService: ObservableObject {
    // æœç´¢å…³é”®è¯
    @Published var searchText: String = ""

    // è¿‡æ»¤æ¡ä»¶
    @Published var filters: Set<FilterType> = []

    enum FilterType {
        case onlineOnly      // ä»…åœ¨çº¿ç”¨æˆ·
        case withAvatar      // ä»…æœ‰å¤´åƒçš„ç”¨æˆ·
        case recentlyActive  // æœ€è¿‘æ´»è·ƒï¼ˆ5 åˆ†é’Ÿå†…ï¼‰
    }

    // è¿‡æ»¤é€»è¾‘ï¼ˆçº¯å‡½æ•°ï¼‰
    func filterUsers(_ users: [DiscoveredUser]) -> [DiscoveredUser] {
        var result = users

        // æœç´¢è¿‡æ»¤
        if !searchText.isEmpty {
            result = result.filter { user in
                user.nickname.localizedCaseInsensitiveContains(searchText) ||
                user.hostname.localizedCaseInsensitiveContains(searchText) ||
                user.department?.localizedCaseInsensitiveContains(searchText) == true
            }
        }

        // æ¡ä»¶è¿‡æ»¤
        if filters.contains(.onlineOnly) {
            result = result.filter { $0.isOnline }
        }
        if filters.contains(.withAvatar) {
            result = result.filter { $0.avatarHash != nil }
        }
        if filters.contains(.recentlyActive) {
            let fiveMinutesAgo = Date().addingTimeInterval(-300)
            result = result.filter { $0.lastSeen > fiveMinutesAgo }
        }

        return result
    }
}
```

#### 4. æ•°æ®æ¨¡å‹å¢å¼º

```swift
// User æ¨¡å‹å¢å¼º
@Model
class User {
    // å·²æœ‰å­—æ®µ...
    var nickname: String
    var hostname: String
    var department: String?

    // æ–°å¢å­—æ®µ
    var avatarData: Data?           // å¤´åƒæ•°æ®ï¼ˆCloudKit åŒæ­¥ï¼‰
    var avatarHash: String?         // å¤´åƒ SHA-256 hash
    var lastSeen: Date = Date()     // æœ€ååœ¨çº¿æ—¶é—´
    var isOnline: Bool = false      // åœ¨çº¿çŠ¶æ€
}
```

### æ•°æ®æµ

#### 1. ç”¨æˆ·å‘ç°æµç¨‹ï¼ˆå¢å¼ºç‰ˆï¼‰

```
ç”¨æˆ· A å¯åŠ¨åº”ç”¨
    â†“
1. å‘é€ BR_ENTRYï¼ˆè¿›å…¥å¹¿æ’­ï¼‰
    â”œâ”€ åŸºç¡€ä¿¡æ¯ï¼šnickname, hostname, department
    â”œâ”€ å¤´åƒå…ƒæ•°æ®ï¼šavatarHash
    â””â”€ UDP å¹¿æ’­ â†’ ç«¯å£ 2425
    â†“
å±€åŸŸç½‘å†…æ‰€æœ‰ç”¨æˆ·æ”¶åˆ°å¹¿æ’­
    â†“
2. ç”¨æˆ· B è§£æå¹¿æ’­åŒ…
    â”œâ”€ æ›´æ–° DiscoveredUser åˆ—è¡¨
    â”œâ”€ æ£€æŸ¥ avatarHash
    â”‚   â””â”€ å¦‚æœæœ¬åœ°æ²¡æœ‰è¯¥ hash çš„å¤´åƒ
    â”‚       â””â”€ TCP è¯·æ±‚å¤´åƒæ•°æ®ï¼ˆæŒ‰éœ€ä¸‹è½½ï¼‰
    â””â”€ æ›´æ–° lastSeen æ—¶é—´æˆ³
    â†“
3. ç”¨æˆ· B å›å¤ BR_ANSENTRYï¼ˆåº”ç­”å¹¿æ’­ï¼‰
    â””â”€ åŒæ ·æºå¸¦è‡ªå·±çš„ avatarHash
    â†“
4. åŒæ–¹éƒ½åœ¨ DiscoveryView ä¸­çœ‹åˆ°å¯¹æ–¹
    â””â”€ å¤´åƒæ˜¾ç¤ºï¼ˆä¼˜å…ˆä½¿ç”¨æœ¬åœ°ç¼“å­˜ï¼‰
```

#### 2. å¤´åƒä¼ è¾“æµç¨‹

**åœºæ™¯ Aï¼šè®¾ç½®å¤´åƒï¼ˆæœ¬åœ° + CloudKitï¼‰**
```
ç”¨æˆ·åœ¨"æˆ‘"é¡µé¢é€‰æ‹©å¤´åƒ
    â†“
AvatarService.setMyAvatar(imageData)
    â”œâ”€ 1. è®¡ç®— SHA-256 hash
    â”œâ”€ 2. ä¿å­˜åˆ° User.avatarDataï¼ˆSwiftData + CloudKit åŒæ­¥ï¼‰
    â”œâ”€ 3. UDP å¹¿æ’­ IPMSG_AVATARï¼ˆæºå¸¦ hashï¼‰
    â””â”€ 4. å…¶ä»–è®¾å¤‡é€šè¿‡ CloudKit è‡ªåŠ¨åŒæ­¥
         â””â”€ iPhone â†” iPad â†” Mac â†” Watch
```

**åœºæ™¯ Bï¼šä¸‹è½½å…¶ä»–ç”¨æˆ·å¤´åƒï¼ˆå±€åŸŸç½‘ TCPï¼‰**
```
DiscoveryView æ˜¾ç¤ºç”¨æˆ·åˆ—è¡¨
    â†“
å‘ç°ç”¨æˆ·æœ‰ avatarHash ä½†æœ¬åœ°æ— ç¼“å­˜
    â†“
AvatarService.requestAvatar(userId, hash)
    â”œâ”€ 1. TCP è¿æ¥åˆ°ç”¨æˆ· IP:2425
    â”œâ”€ 2. å‘é€ IPMSG_GETAVATAR å‘½ä»¤
    â”œâ”€ 3. æ¥æ”¶å¤´åƒæ•°æ®ï¼ˆæœ€å¤§ 1MBï¼ŒJPEG å‹ç¼©ï¼‰
    â”œâ”€ 4. ç¼“å­˜åˆ°å†…å­˜ï¼ˆavatarCacheï¼‰
    â””â”€ 5. æ›´æ–° UI æ˜¾ç¤ºå¤´åƒ
```

#### 3. å¿ƒè·³ä¿æ´»æµç¨‹

```
åº”ç”¨å¯åŠ¨
    â†“
HeartbeatService.startHeartbeat()
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¸»å¾ªç¯ï¼ˆæ¯ 30/60 ç§’ï¼‰               â”‚
â”‚  â”œâ”€ å‘é€ BR_ABSENCE å¹¿æ’­            â”‚
â”‚  â”‚   â”œâ”€ æºå¸¦ç”¨æˆ·åŸºç¡€ä¿¡æ¯             â”‚
â”‚  â”‚   â””â”€ æºå¸¦æœ€è¿‘ 24h æ’¤å›æ¶ˆæ¯åˆ—è¡¨   â”‚ â† Phase 4 åŠŸèƒ½
â”‚  â””â”€ ç­‰å¾…ä¸‹ä¸€ä¸ªå¿ƒè·³å‘¨æœŸ               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¶…æ—¶æ£€æµ‹å¾ªç¯ï¼ˆæ¯ 10 ç§’ï¼‰            â”‚
â”‚  â”œâ”€ æ£€æŸ¥ onlineUsers[userId].lastSeenâ”‚
â”‚  â”œâ”€ å¦‚æœè¶…è¿‡ 60/120 ç§’æ— å¿ƒè·³        â”‚
â”‚  â”‚   â””â”€ æ ‡è®°ä¸ºç¦»çº¿ï¼ˆisOnline = falseï¼‰â”‚
â”‚  â””â”€ ä» DiscoveryView ç§»é™¤æˆ–ç½®ç°     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é”™è¯¯å¤„ç†

#### 1. ç½‘ç»œé”™è¯¯

```swift
enum NetworkError: Error, LocalizedError {
    case udpBroadcastFailed(underlying: Error)
    case tcpConnectionFailed(host: String, port: Int)
    case avatarDownloadFailed(userId: String)
    case avatarTooLarge(size: Int, maxSize: Int)
    case invalidAvatarFormat
}
```

**å¤„ç†ç­–ç•¥**ï¼š
- UDP å¹¿æ’­å¤±è´¥ â†’ é™é»˜é‡è¯• 3 æ¬¡
- TCP å¤´åƒä¸‹è½½å¤±è´¥ â†’ æ˜¾ç¤ºé»˜è®¤å¤´åƒ
- å¤´åƒè¿‡å¤§ â†’ è‡ªåŠ¨å‹ç¼©åˆ° 80% è´¨é‡
- CloudKit åŒæ­¥å¤±è´¥ â†’ æ ‡è®°ä¸º"æœªåŒæ­¥"

#### 2. å¿ƒè·³è¶…æ—¶å¤„ç†

```swift
// æ¸è¿›å¼ç¦»çº¿æ ‡è®°ï¼ˆé¿å…è¯¯åˆ¤ï¼‰
func handleHeartbeatTimeout(userId: String) {
    missedHeartbeats[userId, default: 0] += 1

    switch missedHeartbeats[userId] {
    case 1:
        updateUserStatus(userId, .possiblyOffline) // UI åŠé€æ˜
    case 2:
        updateUserStatus(userId, .offline)          // UI ç½®ç°
    case 3...:
        removeUserFromList(userId)                  // ç§»é™¤
    default:
        break
    }
}
```

### æµ‹è¯•ç­–ç•¥

#### å•å…ƒæµ‹è¯•

- å¤´åƒè®¾ç½®å’Œ hash è®¡ç®—
- å¤´åƒè¿‡å¤§æ—¶è‡ªåŠ¨å‹ç¼©
- å¿ƒè·³è¶…æ—¶æ£€æµ‹
- æœç´¢è¿‡æ»¤é€»è¾‘

#### é›†æˆæµ‹è¯•

- å®Œæ•´ç”¨æˆ·å‘ç°æµç¨‹
- å¤´åƒä¼ è¾“æµç¨‹
- å¿ƒè·³ä¿æ´»éªŒè¯

#### æ‰‹åŠ¨æµ‹è¯•æ¸…å•

- ç”¨æˆ·å‘ç°åŠŸèƒ½
- å¤´åƒåŠŸèƒ½ï¼ˆè®¾ç½®ã€åŒæ­¥ã€æ˜¾ç¤ºï¼‰
- æœç´¢è¿‡æ»¤åŠŸèƒ½
- å¿ƒè·³ä¿æ´»éªŒè¯

---

## Phase 4ï¼šèŠå¤©ä½“éªŒå¢å¼º

**ç›®æ ‡**ï¼šå®ç° TCP æ¶ˆæ¯æ”¶å‘ã€æ¶ˆæ¯æ’¤å›ã€è¾“å…¥çŠ¶æ€æç¤ºå’Œæ¶ˆæ¯æ“ä½œåŠŸèƒ½ã€‚

### æ¶æ„è®¾è®¡

#### æ¨¡å—æ¶æ„

```
Phase 4 æ¶æ„å±‚æ¬¡ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     ConversationDetailView (UI)         â”‚ â† èŠå¤©è¯¦æƒ… + æ¶ˆæ¯åˆ—è¡¨
â”‚  â”œâ”€ MessageBubbleView                   â”‚ â† æ¶ˆæ¯æ°”æ³¡ï¼ˆå¢å¼ºï¼‰
â”‚  â”œâ”€ TypingIndicatorView (æ–°å¢)          â”‚ â† è¾“å…¥çŠ¶æ€æç¤º
â”‚  â”œâ”€ MessageContextMenu (æ–°å¢)           â”‚ â† é•¿æŒ‰èœå•ï¼ˆæ’¤å›/å¤åˆ¶/è½¬å‘ï¼‰
â”‚  â””â”€ InputBar (å¢å¼º)                     â”‚ â† è¾“å…¥æ¡† + å‘é€æŒ‰é’®
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      ConversationService (ä¸šåŠ¡å±‚)       â”‚ â† ä¼šè¯ç®¡ç†åè°ƒå™¨
â”‚  â”œâ”€ TCPMessageService (æ–°å¢)            â”‚ â† TCP æ¶ˆæ¯æ”¶å‘ï¼ˆBSD Socketï¼‰
â”‚  â”œâ”€ RecallService (æ–°å¢)                â”‚ â† æ¶ˆæ¯æ’¤å›ç®¡ç†
â”‚  â”œâ”€ TypingStateService (æ–°å¢)           â”‚ â† è¾“å…¥çŠ¶æ€å¹¿æ’­
â”‚  â””â”€ MessageActionService (æ–°å¢)         â”‚ â† æ¶ˆæ¯æ“ä½œï¼ˆå¤åˆ¶/è½¬å‘ï¼‰
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      IPMsgProtocol (åè®®å±‚æ‰©å±•)         â”‚
â”‚  â”œâ”€ IPMSG_SENDMSG (å·²æœ‰ï¼Œå¢å¼º)          â”‚ â† å‘é€æ¶ˆæ¯ï¼ˆTCPï¼‰
â”‚  â”œâ”€ IPMSG_RECALLMSG (æ–°å¢)              â”‚ â† æ’¤å›æ¶ˆæ¯
â”‚  â”œâ”€ IPMSG_TYPING (æ–°å¢)                 â”‚ â† è¾“å…¥çŠ¶æ€ï¼ˆUDPï¼‰
â”‚  â””â”€ IPMSG_READMSG (å·²æœ‰)                â”‚ â† æ¶ˆæ¯å·²è¯»
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         FluxQModels (æ•°æ®å±‚å¢å¼º)        â”‚
â”‚  â”œâ”€ Message (å¢å¼º)                      â”‚ â† æ–°å¢ isRecalled, recalledAt
â”‚  â”œâ”€ Conversation (å¢å¼º)                 â”‚ â† æ–°å¢ typingUsers
â”‚  â””â”€ MessageAction (æ–°å¢)                â”‚ â† æ¶ˆæ¯æ“ä½œè®°å½•
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ç½‘ç»œå±‚æ¶æ„ï¼ˆæ··åˆå®ç°ï¼‰

```
UDP å±‚ï¼ˆNetwork.framework - Phase 3 å·²æœ‰ï¼‰
  â”œâ”€ ç”¨æˆ·å‘ç°å¹¿æ’­
  â”œâ”€ å¿ƒè·³ä¿æ´»
  â””â”€ è¾“å…¥çŠ¶æ€å¹¿æ’­ (æ–°å¢)

TCP å±‚ï¼ˆBSD Socket - Phase 4 æ–°å¢ï¼‰
  â”œâ”€ SocketConnection
  â”‚   â”œâ”€ è¿æ¥ç®¡ç†ï¼ˆå»ºç«‹/ä¿æŒ/æ–­å¼€ï¼‰
  â”‚   â”œâ”€ æ•°æ®æ”¶å‘ï¼ˆsend/recvï¼‰
  â”‚   â””â”€ async/await å°è£…
  â”œâ”€ MessageTransfer
  â”‚   â”œâ”€ æ¶ˆæ¯åˆ†ç‰‡ï¼ˆå¤§äº 8KB æ—¶åˆ†ç‰‡ï¼‰
  â”‚   â”œâ”€ æ¶ˆæ¯ç»„è£…ï¼ˆæ¥æ”¶ç«¯é‡ç»„ï¼‰
  â”‚   â””â”€ æ¶ˆæ¯ç¡®è®¤ï¼ˆACKï¼‰
  â””â”€ FileTransfer (Phase 5 é¢„ç•™)
```

### æ ¸å¿ƒç»„ä»¶

#### 1. TCPMessageService - TCP æ¶ˆæ¯æœåŠ¡

```swift
@MainActor
class TCPMessageService: ObservableObject {
    // Socket è¿æ¥æ± ï¼ˆæ¯ä¸ªç”¨æˆ·ä¸€ä¸ªè¿æ¥ï¼‰
    private var connections: [String: SocketConnection] = [:]

    // æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆç¦»çº¿æ—¶ç¼“å­˜ï¼‰
    private var pendingMessages: [String: [Message]] = [:]

    // å‘é€æ¶ˆæ¯ï¼ˆTCPï¼‰
    func sendMessage(to userId: String, content: String) async throws -> Message {
        let message = Message(
            senderId: getCurrentUserId(),
            receiverId: userId,
            content: content,
            timestamp: Date()
        )

        // ä¿å­˜åˆ°æœ¬åœ°æ•°æ®åº“
        try saveMessage(message)

        // å°è¯•å‘é€
        do {
            let connection = try await getOrCreateConnection(userId: userId)
            try await connection.send(message)
            message.status = .sent
        } catch {
            message.status = .pending
            pendingMessages[userId, default: []].append(message)
            throw error
        }

        return message
    }

    // æ¥æ”¶æ¶ˆæ¯ï¼ˆTCP ç›‘å¬ï¼‰
    func startListening(port: Int = 2425) async throws {
        let socket = try createListeningSocket(port: port)

        Task {
            while !Task.isCancelled {
                if let clientSocket = try? await acceptConnection(socket) {
                    Task {
                        try await handleIncomingMessage(from: clientSocket)
                    }
                }
            }
        }
    }
}

// BSD Socket å°è£…
class SocketConnection {
    private let socket: Int32

    var isConnected: Bool {
        var error: Int32 = 0
        var len = socklen_t(MemoryLayout<Int32>.size)
        getsockopt(socket, SOL_SOCKET, SO_ERROR, &error, &len)
        return error == 0
    }

    init(host: String, port: Int) async throws {
        let fd = socket(AF_INET, SOCK_STREAM, 0)
        guard fd >= 0 else {
            throw TCPError.socketCreationFailed
        }
        self.socket = fd
        try await connect()
    }

    func send(_ message: Message) async throws {
        let packet = try IPMsgPacket.create(
            command: .sendMsg,
            payload: message.content
        )
        let data = packet.encode()

        try await withCheckedThrowingContinuation { continuation in
            data.withUnsafeBytes { buffer in
                let sent = Darwin.send(socket, buffer.baseAddress, buffer.count, 0)
                if sent == buffer.count {
                    continuation.resume()
                } else {
                    continuation.resume(throwing: TCPError.sendFailed)
                }
            }
        }
    }

    deinit {
        close(socket)
    }
}
```

#### 2. RecallService - æ¶ˆæ¯æ’¤å›ç®¡ç†

```swift
@MainActor
class RecallService: ObservableObject {
    // æ’¤å›è®°å½•ï¼ˆæœ€è¿‘ 24 å°æ—¶ï¼‰
    @Published private(set) var recentRecalls: [UUID: Date] = [:]

    // æ’¤å›æ—¶é—´çª—å£ï¼ˆ2 åˆ†é’Ÿ = 120 ç§’ï¼‰
    private let recallWindow: TimeInterval = 120

    // æ’¤å›æ¶ˆæ¯
    func recallMessage(_ message: Message) async throws {
        // 1. æ£€æŸ¥æ—¶é—´çª—å£
        guard canRecall(message) else {
            throw RecallError.timeoutExpired(
                sent: message.timestamp,
                now: Date()
            )
        }

        // 2. æ£€æŸ¥æƒé™
        guard message.senderId == getCurrentUserId() else {
            throw RecallError.notAuthorized
        }

        // 3. æ ‡è®°ä¸ºå·²æ’¤å›ï¼ˆæœ¬åœ°ï¼‰
        message.isRecalled = true
        message.recalledAt = Date()
        try modelContext.save()

        // 4. å‘é€æ’¤å›å‘½ä»¤ï¼ˆTCPï¼‰
        try await tcpService.sendRecallCommand(
            messageId: message.id,
            receiverId: message.receiverId
        )

        // 5. è®°å½•åˆ°æ’¤å›åˆ—è¡¨ï¼ˆç”¨äºç¦»çº¿è¡¥å¿ï¼‰
        recentRecalls[message.id] = Date()
    }

    // å¤„ç†æ”¶åˆ°çš„æ’¤å›å‘½ä»¤
    func handleRecallCommand(messageId: UUID, senderId: String) async throws {
        guard let message = try? getMessage(messageId) else {
            return
        }

        guard message.senderId == senderId else {
            throw RecallError.senderMismatch
        }

        message.isRecalled = true
        message.recalledAt = Date()
        try modelContext.save()
    }

    // è·å–æ’¤å›åˆ—è¡¨ï¼ˆç”¨äºå¿ƒè·³å¹¿æ’­ï¼‰
    func getRecallListForHeartbeat() -> [UUID] {
        let cutoff = Date().addingTimeInterval(-86400) // 24 å°æ—¶å‰
        return recentRecalls
            .filter { $0.value > cutoff }
            .map { $0.key }
    }
}
```

#### 3. TypingStateService - è¾“å…¥çŠ¶æ€å¹¿æ’­

```swift
@MainActor
class TypingStateService: ObservableObject {
    // å½“å‰æ­£åœ¨è¾“å…¥çš„ç”¨æˆ·
    @Published private(set) var typingUsers: [UUID: Set<String>] = [:]

    // è¾“å…¥çŠ¶æ€è¶…æ—¶ï¼ˆ3 ç§’ï¼‰
    private let typingTimeout: TimeInterval = 3.0

    // å¹¿æ’­è¾“å…¥çŠ¶æ€ï¼ˆèŠ‚æµï¼šæ¯ 1 ç§’æœ€å¤šä¸€æ¬¡ï¼‰
    private var lastBroadcast: Date = .distantPast

    func startTyping(conversationId: UUID, recipientId: String) async throws {
        guard Date().timeIntervalSince(lastBroadcast) >= 1.0 else {
            return
        }

        let command = IPMsgCommand.typing(
            conversationId: conversationId,
            userId: getCurrentUserId()
        )
        try await udpService.broadcast(command)
        lastBroadcast = Date()
    }

    func handleTypingState(conversationId: UUID, userId: String, isTyping: Bool) {
        if isTyping {
            typingUsers[conversationId, default: []].insert(userId)

            Task {
                try? await Task.sleep(for: .seconds(typingTimeout))
                typingUsers[conversationId]?.remove(userId)
            }
        } else {
            typingUsers[conversationId]?.remove(userId)
        }
    }
}
```

#### 4. MessageActionService - æ¶ˆæ¯æ“ä½œ

```swift
@MainActor
class MessageActionService {
    // å¤åˆ¶æ¶ˆæ¯å†…å®¹
    func copyMessage(_ message: Message) {
        #if os(iOS)
        UIPasteboard.general.string = message.content
        #elseif os(macOS)
        NSPasteboard.general.setString(message.content, forType: .string)
        #endif
    }

    // è½¬å‘æ¶ˆæ¯
    func forwardMessage(_ message: Message, to recipientId: String) async throws {
        let forwardedContent = "ã€è½¬å‘ã€‘\(message.content)"
        try await tcpService.sendMessage(to: recipientId, content: forwardedContent)
    }
}
```

### æ•°æ®æµ

#### 1. æ¶ˆæ¯å‘é€æµç¨‹ï¼ˆTCPï¼‰

```
ç”¨æˆ·åœ¨ InputBar è¾“å…¥æ¶ˆæ¯å¹¶ç‚¹å‡»å‘é€
    â†“
TCPMessageService.sendMessage()
    â”œâ”€ åˆ›å»º Message å¯¹è±¡å¹¶ä¿å­˜ï¼ˆstatus = .sendingï¼‰
    â”œâ”€ è·å–æˆ–åˆ›å»º TCP è¿æ¥
    â”œâ”€ å°è£… IPMsg æ•°æ®åŒ…
    â”œâ”€ é€šè¿‡ BSD Socket å‘é€
    â””â”€ æ›´æ–°æ¶ˆæ¯çŠ¶æ€ï¼ˆsent/pending/failedï¼‰
    â†“
UI è‡ªåŠ¨æ›´æ–°ï¼ˆSwiftUIï¼‰
```

#### 2. æ¶ˆæ¯æ’¤å›æµç¨‹

**åœ¨çº¿æ’¤å›ï¼ˆå®æ—¶ï¼‰**ï¼š
```
ç”¨æˆ·é•¿æŒ‰æ¶ˆæ¯æ°”æ³¡ â†’ é€‰æ‹©"æ’¤å›"
    â†“
RecallService.recallMessage()
    â”œâ”€ æ£€æŸ¥æ—¶é—´çª—å£ï¼ˆ2 åˆ†é’Ÿå†…ï¼‰
    â”œâ”€ æœ¬åœ°æ ‡è®°ä¸ºå·²æ’¤å›
    â””â”€ å‘é€ TCP æ’¤å›å‘½ä»¤
    â†“
æ¥æ”¶æ–¹æ”¶åˆ°æ’¤å›å‘½ä»¤
    â””â”€ æ ‡è®°æ¶ˆæ¯ä¸ºå·²æ’¤å›
```

**ç¦»çº¿è¡¥å¿ï¼ˆå¿ƒè·³å¹¿æ’­ï¼‰**ï¼š
```
ç”¨æˆ· A æ’¤å›æ¶ˆæ¯æ—¶ï¼Œç”¨æˆ· B ç¦»çº¿
    â†“
è®°å½•åˆ° recentRecallsï¼ˆæœ€è¿‘ 24 å°æ—¶ï¼‰
    â†“
ä¸‹æ¬¡å¿ƒè·³å¹¿æ’­æºå¸¦æ’¤å›åˆ—è¡¨
    â†“
ç”¨æˆ· B ä¸Šçº¿å¹¶æ”¶åˆ°å¿ƒè·³å¹¿æ’­
    â””â”€ è§£ææ’¤å›åˆ—è¡¨å¹¶æ ‡è®°æ¶ˆæ¯
```

### é”™è¯¯å¤„ç†

#### TCP è¿æ¥é”™è¯¯

```swift
enum TCPError: Error, LocalizedError {
    case socketCreationFailed
    case connectionFailed(host: String, port: Int)
    case connectionTimeout
    case sendFailed
    case receiveFailed
}
```

**å¤„ç†ç­–ç•¥**ï¼š
- è¿æ¥å¤±è´¥ â†’ è‡ªåŠ¨é‡è¯• 3 æ¬¡ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
- å‘é€å¤±è´¥ â†’ åŠ å…¥å¾…å‘é€é˜Ÿåˆ—ï¼Œåå°é‡è¯•
- ç½‘ç»œæ–­å¼€ â†’ ç›‘æ§æ¢å¤ï¼Œè‡ªåŠ¨é‡è¯•æ‰€æœ‰å¾…å‘é€æ¶ˆæ¯

#### æ¶ˆæ¯æ’¤å›é”™è¯¯

- è¶…æ—¶æ’¤å› â†’ æ˜¾ç¤ºé”™è¯¯æç¤º
- æƒé™é”™è¯¯ â†’ æ˜¾ç¤ºé”™è¯¯æç¤º
- ç½‘ç»œé”™è¯¯ â†’ æ˜¾ç¤ºé‡è¯•é€‰é¡¹

### æµ‹è¯•ç­–ç•¥

#### å•å…ƒæµ‹è¯•

- Socket è¿æ¥åˆ›å»º
- æ¶ˆæ¯å‘é€å’Œæ¥æ”¶
- æ’¤å›æ—¶é—´çª—å£æ£€æŸ¥
- è¾“å…¥çŠ¶æ€èŠ‚æµ
- ç½‘ç»œæ–­å¼€åè‡ªåŠ¨é‡è¯•

#### é›†æˆæµ‹è¯•

- å®Œæ•´èŠå¤©æµç¨‹
- è¾“å…¥çŠ¶æ€æç¤ºæµç¨‹
- ç¦»çº¿æ¶ˆæ¯è¡¥å¿

---

## Phase 5ï¼šå®Œæ•´ watchOS ä½“éªŒ

**ç›®æ ‡**ï¼šå®ç° Watch Connectivityã€ç‹¬ç«‹ç½‘ç»œã€Complication å’Œå¿«é€Ÿå›å¤åŠŸèƒ½ã€‚

### æ¶æ„è®¾è®¡

#### æ¨¡å—æ¶æ„

```
Phase 5 æ¶æ„å±‚æ¬¡ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      FluxQWatch App (watchOS)           â”‚
â”‚  â”œâ”€ MessageListView                     â”‚
â”‚  â”œâ”€ ConversationView (å¢å¼º)             â”‚
â”‚  â”œâ”€ QuickReplyView (æ–°å¢)               â”‚
â”‚  â”œâ”€ ComplicationView (æ–°å¢)             â”‚
â”‚  â””â”€ SettingsView                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     WatchConnectivityService (æ¡¥æ¥å±‚)   â”‚
â”‚  â”œâ”€ MessageSyncService                  â”‚
â”‚  â”œâ”€ UserSyncService                     â”‚
â”‚  â””â”€ NetworkDelegationService            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     WatchNetworkService (ç‹¬ç«‹ç½‘ç»œå±‚)    â”‚
â”‚  â”œâ”€ WatchUDPService (æ–°å¢)              â”‚
â”‚  â”œâ”€ WatchTCPService (æ–°å¢)              â”‚
â”‚  â””â”€ NetworkModeManager (æ–°å¢)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      ComplicationService (æ–°å¢)         â”‚
â”‚  â”œâ”€ TimelineProvider                    â”‚
â”‚  â””â”€ ComplicationDataSource              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ç½‘ç»œæ¨¡å¼åˆ‡æ¢æ¶æ„

```
NetworkModeManagerï¼šæ™ºèƒ½æ¨¡å¼åˆ‡æ¢
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ¨¡å¼ 1: Companion Mode (ä¼´éšæ¨¡å¼)      â”‚
â”‚  æ¡ä»¶ï¼šiPhone åœ¨é™„è¿‘ä¸”å¯è¾¾               â”‚
â”‚  â”œâ”€ æ‰€æœ‰ç½‘ç»œæ“ä½œé€šè¿‡ Watch Connectivity â”‚
â”‚  â””â”€ ä¼˜åŠ¿ï¼šçœç”µã€ç¨³å®š                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¨¡å¼ 2: Standalone Mode (ç‹¬ç«‹æ¨¡å¼)     â”‚
â”‚  æ¡ä»¶ï¼šWi-Fi Watch + iPhone ä¸åœ¨é™„è¿‘    â”‚
â”‚  â”œâ”€ ç›´æ¥è¿è¡Œ UDP/TCP æœåŠ¡                â”‚
â”‚  â””â”€ ä¼˜åŠ¿ï¼šå®Œæ•´åŠŸèƒ½                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¨¡å¼ 3: Offline Mode (ç¦»çº¿æ¨¡å¼)        â”‚
â”‚  æ¡ä»¶ï¼šGPS Watch + iPhone ä¸åœ¨é™„è¿‘      â”‚
â”‚  â”œâ”€ åªè¯»æ¨¡å¼ï¼ˆæŸ¥çœ‹å†å²æ¶ˆæ¯ï¼‰             â”‚
â”‚  â””â”€ ä¼˜åŠ¿ï¼šåŸºæœ¬å¯ç”¨                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶

#### 1. NetworkModeManager - ç½‘ç»œæ¨¡å¼ç®¡ç†å™¨

```swift
@MainActor
class NetworkModeManager: ObservableObject {
    @Published private(set) var currentMode: NetworkMode = .offline

    enum NetworkMode {
        case companion    // ä¼´éšæ¨¡å¼ï¼ˆiPhone ä»£ç†ï¼‰
        case standalone   // ç‹¬ç«‹æ¨¡å¼ï¼ˆWi-Fi Watchï¼‰
        case offline      // ç¦»çº¿æ¨¡å¼ï¼ˆGPS Watchï¼‰
    }

    func startMonitoring() {
        // ç›‘å¬ Watch Connectivity çŠ¶æ€
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(updateNetworkMode),
            name: .WCSessionReachabilityDidChange,
            object: nil
        )

        // å®šæœŸæ£€æµ‹ï¼ˆæ¯ 5 ç§’ï¼‰
        Task {
            while !Task.isCancelled {
                updateNetworkMode()
                try? await Task.sleep(for: .seconds(5))
            }
        }
    }

    private func determineNetworkMode() -> NetworkMode {
        if wcSession.isReachable {
            return .companion
        }

        #if os(watchOS)
        if device.isWiFiEnabled {
            return .standalone
        }
        #endif

        return .offline
    }

    private func switchToMode(_ mode: NetworkMode) async throws {
        switch mode {
        case .companion:
            try? await watchNetworkService.stop()
            try await watchConnectivityService.start()
        case .standalone:
            watchConnectivityService.stop()
            try await watchNetworkService.start()
        case .offline:
            watchConnectivityService.stop()
            try? await watchNetworkService.stop()
        }
    }
}
```

#### 2. WatchConnectivityService - Watch Connectivity æ¡¥æ¥

```swift
@MainActor
class WatchConnectivityService: NSObject, WCSessionDelegate {
    private let session = WCSession.default

    @Published private(set) var isReachable: Bool = false

    // å‘é€æ¶ˆæ¯ï¼ˆWatch â†’ iPhoneï¼‰
    func sendMessage(to userId: String, content: String) async throws {
        guard session.isReachable else {
            throw WatchError.iPhoneNotReachable
        }

        let payload: [String: Any] = [
            "action": "sendMessage",
            "recipientId": userId,
            "content": content,
            "timestamp": Date().timeIntervalSince1970
        ]

        try await withCheckedThrowingContinuation { continuation in
            session.sendMessage(payload, replyHandler: { _ in
                continuation.resume()
            }, errorHandler: { error in
                continuation.resume(throwing: error)
            })
        }
    }

    // æ¥æ”¶æ¶ˆæ¯ï¼ˆiPhone â†’ Watchï¼‰
    func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
        Task { @MainActor in
            guard let action = message["action"] as? String else { return }

            switch action {
            case "newMessage":
                try? await handleNewMessage(message)
            case "messageRecalled":
                try? await handleMessageRecalled(message)
            default:
                break
            }
        }
    }
}
```

#### 3. WatchNetworkService - ç‹¬ç«‹ç½‘ç»œæœåŠ¡

```swift
@MainActor
class WatchNetworkService: ObservableObject {
    // å¤ç”¨ Phase 3 å’Œ Phase 4 çš„æœåŠ¡
    private let udpService: UDPDiscoveryService
    private let tcpService: TCPMessageService
    private let heartbeatService: HeartbeatService

    // watchOS ç‰¹å®šé…ç½®
    private let config = WatchNetworkConfig(
        heartbeatInterval: 60.0,  // 60 ç§’å¿ƒè·³
        timeoutInterval: 120.0,   // 120 ç§’è¶…æ—¶
        maxConcurrentConnections: 3
    )

    func start() async throws {
        try await udpService.start()
        try await tcpService.startListening(port: 2425)
        heartbeatService.startHeartbeat()
        try await udpService.sendEntryBroadcast()
    }
}
```

#### 4. ComplicationService - è¡¨ç›˜å¤æ‚åŠŸèƒ½

```swift
@MainActor
class ComplicationService {
    func getUnreadCount() -> Int {
        let request = FetchDescriptor<Message>(
            predicate: #Predicate { !$0.isRead }
        )
        return (try? modelContext.fetchCount(request)) ?? 0
    }

    func getComplicationData(for family: CLKComplicationFamily) -> CLKComplicationTemplate? {
        let unreadCount = getUnreadCount()
        let latestMessage = getLatestMessage()

        switch family {
        case .circularSmall:
            let template = CLKComplicationTemplateCircularSmallSimpleText()
            template.textProvider = CLKSimpleTextProvider(text: "\(unreadCount)")
            return template

        case .modularLarge:
            let template = CLKComplicationTemplateModularLargeStandardBody()
            template.headerTextProvider = CLKSimpleTextProvider(text: "FluxQ")
            if let message = latestMessage {
                template.body1TextProvider = CLKSimpleTextProvider(text: message.content)
            }
            return template

        default:
            return nil
        }
    }
}
```

#### 5. QuickReplyService - å¿«é€Ÿå›å¤

```swift
@MainActor
class QuickReplyService {
    static let quickReplies: [String] = [
        "å¥½çš„", "æ”¶åˆ°", "ç¨åå›å¤", "åœ¨å¿™ï¼Œæ™šç‚¹èŠ",
        "ğŸ‘", "ğŸ˜Š", "ğŸ™", "â¤ï¸"
    ]

    func sendQuickReply(_ reply: String, to userId: String) async throws {
        let networkMode = networkModeManager.currentMode

        switch networkMode {
        case .companion:
            try await watchConnectivityService.sendMessage(to: userId, content: reply)
        case .standalone:
            try await watchNetworkService.tcpService.sendMessage(to: userId, content: reply)
        case .offline:
            // ç¼“å­˜æ¶ˆæ¯ï¼Œç­‰å¾…åŒæ­¥
            let message = Message(...)
            message.status = .pending
            try modelContext.save()
        }
    }
}
```

### æ•°æ®æµ

#### 1. ç½‘ç»œæ¨¡å¼è‡ªåŠ¨åˆ‡æ¢æµç¨‹

```
Watch åº”ç”¨å¯åŠ¨
    â†“
NetworkModeManager.startMonitoring()
    â†“
æ£€æµ‹è®¾å¤‡çŠ¶æ€ï¼ˆæ¯ 5 ç§’ï¼‰
    â†“
WCSession.isReachable?
    â”œâ”€ YES â†’ ä¼´éšæ¨¡å¼
    â””â”€ NO â†’ ç»§ç»­æ£€æµ‹
         â†“
         WKInterfaceDevice.isWiFiEnabled?
         â”œâ”€ YES â†’ ç‹¬ç«‹æ¨¡å¼
         â””â”€ NO â†’ ç¦»çº¿æ¨¡å¼
```

#### 2. Watch Connectivity æ¶ˆæ¯åŒæ­¥

**å‘é€æ¶ˆæ¯ï¼ˆWatch â†’ iPhone â†’ å¯¹æ–¹ï¼‰**ï¼š
```
Watch å‘é€æ¶ˆæ¯
    â†“
WatchConnectivityService.sendMessage()
    â†“
iPhone æ”¶åˆ° â†’ é€šè¿‡ TCP å‘é€
    â†“
Watch æ”¶åˆ°ç¡®è®¤
```

**æ¥æ”¶æ¶ˆæ¯ï¼ˆå¯¹æ–¹ â†’ iPhone â†’ Watchï¼‰**ï¼š
```
iPhone æ”¶åˆ°æ–°æ¶ˆæ¯
    â†“
iPhone å‘é€åˆ° Watchï¼ˆUserInfo Transferï¼‰
    â†“
Watch æ”¶åˆ° â†’ ä¿å­˜ + æ›´æ–° Complication + é€šçŸ¥
```

#### 3. Complication æ›´æ–°æµç¨‹

```
è§¦å‘æ›´æ–°ï¼š
  â”œâ”€ æ”¶åˆ°æ–°æ¶ˆæ¯
  â”œâ”€ æ¶ˆæ¯æ ‡è®°ä¸ºå·²è¯»
  â””â”€ æ¯ 15 åˆ†é’Ÿå®šæ—¶æ›´æ–°
    â†“
ComplicationController.reloadComplications()
    â†“
ç³»ç»Ÿè°ƒç”¨ getCurrentTimelineEntry()
    â†“
è¿”å› CLKComplicationTimelineEntry
    â†“
è¡¨ç›˜æ˜¾ç¤ºæ›´æ–°
```

### é”™è¯¯å¤„ç†

#### æ¨¡å¼åˆ‡æ¢é”™è¯¯

```swift
enum WatchError: Error {
    case watchConnectivityNotSupported
    case iPhoneNotReachable
    case wifiNotAvailable
    case networkModeSwitchFailed(from: NetworkMode, to: NetworkMode)
}
```

**å¤„ç†ç­–ç•¥**ï¼š
- æ¨¡å¼åˆ‡æ¢å¤±è´¥ â†’ å›é€€åˆ°ä¹‹å‰çš„æ¨¡å¼
- iPhone ä¸å¯è¾¾ â†’ é™çº§åˆ°ç‹¬ç«‹/ç¦»çº¿æ¨¡å¼
- ç”µæ± ç”µé‡ä½ï¼ˆ<20%ï¼‰ â†’ è‡ªåŠ¨é™çº§åˆ°ç¦»çº¿æ¨¡å¼

#### é™çº§ç­–ç•¥

```swift
enum DegradationStrategy {
    case full           // å®Œæ•´åŠŸèƒ½
    case sendOnly       // ä»…å‘é€ï¼ˆé€šè¿‡ iPhoneï¼‰
    case receiveOnly    // ä»…æ¥æ”¶ï¼ˆUDP å¹¿æ’­ï¼‰
    case readOnly       // åªè¯»ï¼ˆæœ¬åœ°ç¼“å­˜ï¼‰
}
```

### æµ‹è¯•ç­–ç•¥

#### å•å…ƒæµ‹è¯•

- ç½‘ç»œæ¨¡å¼æ£€æµ‹
- æ¨¡å¼åˆ‡æ¢é€»è¾‘
- Watch Connectivity å‘é€æ¶ˆæ¯
- ç‹¬ç«‹ç½‘ç»œæœåŠ¡å¯åŠ¨
- Complication æ•°æ®ç”Ÿæˆ
- å¿«é€Ÿå›å¤å‘é€

#### é›†æˆæµ‹è¯•

- å®Œæ•´æ¨¡å¼åˆ‡æ¢æµç¨‹
- ä¼´éšæ¨¡å¼æ¶ˆæ¯æ”¶å‘
- ç‹¬ç«‹æ¨¡å¼ç½‘ç»œé€šä¿¡
- Complication æ›´æ–°æµç¨‹

#### æ‰‹åŠ¨æµ‹è¯•æ¸…å•

- ç½‘ç»œæ¨¡å¼åˆ‡æ¢
- ä¼´éšæ¨¡å¼åŠŸèƒ½
- ç‹¬ç«‹æ¨¡å¼åŠŸèƒ½
- å¿«é€Ÿå›å¤
- Complication æ˜¾ç¤º
- ç¦»çº¿æ¨¡å¼
- ç”µæ± å’Œæ€§èƒ½

---

## å®æ–½è®¡åˆ’

### æ–¹æ¡ˆ Aï¼šé¡ºåºå®æ–½ï¼ˆæ¨èï¼‰

```
Week 1:
  â””â”€ Phase 3: å±€åŸŸç½‘å‘ç°å¢å¼º âœ…

Week 2-3:
  â””â”€ Phase 4: èŠå¤©ä½“éªŒå¢å¼º âœ…

Week 4:
  â””â”€ Phase 5: å®Œæ•´ watchOS ä½“éªŒ âœ…
```

**æ€»æ—¶é—´**ï¼š3.5-4 å‘¨

**ä¼˜ç‚¹**ï¼š
- é£é™©ä½ï¼Œæ¯ä¸ª Phase å……åˆ†éªŒè¯
- é—®é¢˜éš”ç¦»æ¸…æ™°ï¼Œä¾¿äºè°ƒè¯•
- é€‚åˆå•äººå¼€å‘

### ä¾èµ–å…³ç³»

```
Phase 5 ä¾èµ–ï¼š
  â”œâ”€ Phase 3: UDPDiscoveryServiceï¼ˆç‹¬ç«‹æ¨¡å¼ï¼‰
  â”œâ”€ Phase 4: TCPMessageServiceï¼ˆç‹¬ç«‹æ¨¡å¼ï¼‰
  â””â”€ Watch Connectivity Framework

Phase 4 ä¾èµ–ï¼š
  â””â”€ Phase 3: HeartbeatServiceï¼ˆæ’¤å›åˆ—è¡¨æºå¸¦ï¼‰
```

---

## éªŒæ”¶æ ‡å‡†

### Phase 3

- [ ] ç”¨æˆ·å¯ä»¥è®¾ç½®å¤´åƒï¼Œå¹¶åœ¨æ‰€æœ‰è®¾å¤‡åŒæ­¥
- [ ] ç”¨æˆ·åˆ—è¡¨æ˜¾ç¤ºå…¶ä»–ç”¨æˆ·çš„å¤´åƒ
- [ ] æœç´¢å’Œè¿‡æ»¤åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- [ ] å¿ƒè·³ä¿æ´»æœºåˆ¶æ­£ç¡®æ ‡è®°åœ¨çº¿/ç¦»çº¿çŠ¶æ€
- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] æ‰€æœ‰é›†æˆæµ‹è¯•é€šè¿‡

### Phase 4

- [ ] ç”¨æˆ·å¯ä»¥å‘é€å’Œæ¥æ”¶æ–‡æœ¬æ¶ˆæ¯
- [ ] æ¶ˆæ¯å‘é€çŠ¶æ€æ­£ç¡®æ˜¾ç¤º
- [ ] 2 åˆ†é’Ÿå†…å¯ä»¥æ’¤å›æ¶ˆæ¯
- [ ] è¾“å…¥çŠ¶æ€æç¤ºæ­£å¸¸å·¥ä½œ
- [ ] æ¶ˆæ¯å¤åˆ¶å’Œè½¬å‘åŠŸèƒ½æ­£å¸¸
- [ ] ç½‘ç»œæ–­å¼€åè‡ªåŠ¨é‡è¯•
- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] æ‰€æœ‰é›†æˆæµ‹è¯•é€šè¿‡

### Phase 5

- [ ] ç½‘ç»œæ¨¡å¼è‡ªåŠ¨åˆ‡æ¢æ­£å¸¸
- [ ] ä¼´éšæ¨¡å¼ä¸‹æ¶ˆæ¯æ”¶å‘æ­£å¸¸
- [ ] ç‹¬ç«‹æ¨¡å¼ä¸‹å®Œæ•´åŠŸèƒ½å¯ç”¨
- [ ] Complication æ­£ç¡®æ˜¾ç¤ºæœªè¯»æ•°
- [ ] å¿«é€Ÿå›å¤åŠŸèƒ½æ­£å¸¸
- [ ] ç¦»çº¿æ¨¡å¼ä¸‹å¯ä»¥æŸ¥çœ‹å†å²æ¶ˆæ¯
- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] æ‰€æœ‰é›†æˆæµ‹è¯•é€šè¿‡

---

## é£é™©å’Œç¼“è§£æªæ–½

### æŠ€æœ¯é£é™©

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| BSD Socket å®ç°å¤æ‚ | é«˜ | ä¸­ | æå‰éªŒè¯ PoCï¼Œå‚è€ƒ IPMsg åŸå§‹å®ç° |
| Watch Connectivity ä¸ç¨³å®š | ä¸­ | ä¸­ | å®ç°ç‹¬ç«‹ç½‘ç»œæ¨¡å¼ä½œä¸ºé™çº§æ–¹æ¡ˆ |
| CloudKit åŒæ­¥å†²çª | ä¸­ | ä½ | SwiftData è‡ªåŠ¨å¤„ç†ï¼Œæµ‹è¯•å†²çªåœºæ™¯ |
| watchOS ç”µæ± ç»­èˆª | é«˜ | ä¸­ | èŠ‚èƒ½å¿ƒè·³ç­–ç•¥ï¼Œä½ç”µé‡è‡ªåŠ¨é™çº§ |

### æ—¶é—´é£é™©

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| Phase 4 TCP å®ç°è¶…æ—¶ | é«˜ | ä¸­ | é¢„ç•™ 0.5 å‘¨ç¼“å†²æ—¶é—´ |
| Phase 5 æ¨¡å¼åˆ‡æ¢å¤æ‚ | ä¸­ | ä¸­ | ä¼˜å…ˆå®ç°ä¼´éšæ¨¡å¼ï¼Œç‹¬ç«‹æ¨¡å¼å¯é€‰ |

---

## é™„å½•

### åè®®æ‰©å±•

#### æ–°å¢å‘½ä»¤

```
IPMSG_AVATAR        = 0x00020000  // å¤´åƒå…ƒæ•°æ®ï¼ˆUDPï¼‰
IPMSG_GETAVATAR     = 0x00030000  // è¯·æ±‚å¤´åƒï¼ˆTCPï¼‰
IPMSG_RECALLMSG     = 0x00010000  // æ’¤å›æ¶ˆæ¯ï¼ˆTCPï¼‰
IPMSG_TYPING        = 0x00040000  // è¾“å…¥çŠ¶æ€ï¼ˆUDPï¼‰
IPMSG_STOPTYPING    = 0x00050000  // åœæ­¢è¾“å…¥ï¼ˆUDPï¼‰
IPMSG_RECALLLIST    = 0x00060000  // æ’¤å›åˆ—è¡¨ï¼ˆUDPï¼Œå¿ƒè·³æºå¸¦ï¼‰
```

### æ•°æ®æ¨¡å‹å˜æ›´

```swift
// User æ¨¡å‹
@Model
class User {
    var avatarData: Data?           // æ–°å¢
    var avatarHash: String?         // æ–°å¢
    var lastSeen: Date = Date()     // æ–°å¢
    var isOnline: Bool = false      // æ–°å¢
}

// Message æ¨¡å‹
@Model
class Message {
    var isRecalled: Bool = false    // æ–°å¢
    var recalledAt: Date?           // æ–°å¢
    var status: MessageStatus       // æ–°å¢
}

enum MessageStatus: Codable {
    case sending
    case sent
    case pending
    case failed
}
```

### å‚è€ƒèµ„æ–™

- [IP Messenger åè®®è§„èŒƒ](http://ipmsg.org/)
- [BSD Socket ç¼–ç¨‹æŒ‡å—](https://beej.us/guide/bgnet/)
- [Watch Connectivity å®˜æ–¹æ–‡æ¡£](https://developer.apple.com/documentation/watchconnectivity)
- [ClockKit å®˜æ–¹æ–‡æ¡£](https://developer.apple.com/documentation/clockkit)

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0
**æœ€åæ›´æ–°**ï¼š2026-02-14
**ä½œè€…**ï¼šClaude Sonnet 4.5

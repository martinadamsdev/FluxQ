# FluxQ DMG 自动构建 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 在 Xcode 中选择 `FluxQ DMG` scheme 后 ⌘B 自动构建签名公证的 DMG。

**Architecture:**
新增 3 个脚本 + 1 个 Xcode Aggregate Target。`build-dmg.sh` 为入口脚本，被 Aggregate Target 的 Run Script Phase 调用，内部编排签名公证和 DMG 打包。

**Tech Stack:** hdiutil, codesign, xcrun notarytool, xcrun stapler, Xcode Aggregate Target

---

### Task 1: create-dmg.sh — DMG 打包脚本

负责将 .app 打包为带 Applications 快捷方式的 DMG。

**Files:**
- Create: `scripts/create-dmg.sh`

**Step 1: 创建脚本**

创建 `scripts/create-dmg.sh`：

```bash
#!/bin/bash
set -euo pipefail

# Usage: create-dmg.sh <path-to-app> [output-dir]
APP_PATH="${1:?Usage: create-dmg.sh <path-to-app> [output-dir]}"
OUTPUT_DIR="${2:-build}"

APP_NAME=$(basename "$APP_PATH" .app)
VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$APP_PATH/Contents/Info.plist" 2>/dev/null || echo "1.0.0")
DMG_NAME="${APP_NAME}-${VERSION}.dmg"

echo "==> 创建 DMG: $DMG_NAME"

# 准备临时目录
STAGING_DIR=$(mktemp -d)
trap 'rm -rf "$STAGING_DIR"' EXIT

cp -R "$APP_PATH" "$STAGING_DIR/"
ln -s /Applications "$STAGING_DIR/Applications"

# 确保输出目录存在
mkdir -p "$OUTPUT_DIR"

DMG_PATH="$OUTPUT_DIR/$DMG_NAME"
rm -f "$DMG_PATH"

# 创建 DMG
hdiutil create "$DMG_PATH" \
  -volname "$APP_NAME" \
  -srcfolder "$STAGING_DIR" \
  -ov \
  -format UDZO

echo "==> DMG 已生成: $DMG_PATH"
```

**Step 2: 赋予执行权限**

Run: `chmod +x scripts/create-dmg.sh`

**Step 3: 验证脚本可独立运行**

先构建一个 Release app 供测试：

Run: `xcodebuild build -scheme FluxQ -configuration Release -destination 'platform=macOS' CONFIGURATION_BUILD_DIR=/tmp/FluxQ-test-build 2>&1 | tail -5`
Expected: BUILD SUCCEEDED

Run: `./scripts/create-dmg.sh /tmp/FluxQ-test-build/FluxQ.app /tmp/FluxQ-test-build`
Expected: "DMG 已生成" 且文件存在

Run: `ls -lh /tmp/FluxQ-test-build/FluxQ-*.dmg`
Expected: 显示 DMG 文件及大小

**Step 4: Commit**

```bash
git add scripts/create-dmg.sh
git commit -m "feat: add create-dmg.sh for DMG packaging with Applications symlink"
```

---

### Task 2: notarize.sh — 签名公证脚本

负责 Developer ID 签名、Apple 公证、票据钉合。

**Files:**
- Create: `scripts/notarize.sh`

**Step 1: 创建脚本**

创建 `scripts/notarize.sh`：

```bash
#!/bin/bash
set -euo pipefail

# Usage: notarize.sh <path-to-app>
# Required env: DEVELOPER_ID_NAME, NOTARIZE_KEYCHAIN_PROFILE
APP_PATH="${1:?Usage: notarize.sh <path-to-app>}"

DEVELOPER_ID_NAME="${DEVELOPER_ID_NAME:?Set DEVELOPER_ID_NAME env var (e.g. 'Developer ID Application: Your Name (TEAMID)')}"
NOTARIZE_KEYCHAIN_PROFILE="${NOTARIZE_KEYCHAIN_PROFILE:?Set NOTARIZE_KEYCHAIN_PROFILE env var (run: xcrun notarytool store-credentials)}"

APP_NAME=$(basename "$APP_PATH" .app)

echo "==> 签名: $APP_PATH"
codesign --deep --force --options runtime \
  --sign "$DEVELOPER_ID_NAME" \
  "$APP_PATH"

codesign --verify --verbose "$APP_PATH"
echo "==> 签名验证通过"

echo "==> 创建 zip 用于公证提交..."
ZIP_PATH=$(mktemp -d)/"${APP_NAME}.zip"
trap 'rm -f "$ZIP_PATH"' EXIT

ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"

echo "==> 提交公证..."
xcrun notarytool submit "$ZIP_PATH" \
  --keychain-profile "$NOTARIZE_KEYCHAIN_PROFILE" \
  --wait

echo "==> 钉合公证票据..."
xcrun stapler staple "$APP_PATH"

echo "==> 公证完成: $APP_PATH"
```

**Step 2: 赋予执行权限**

Run: `chmod +x scripts/notarize.sh`

**Step 3: Commit**

```bash
git add scripts/notarize.sh
git commit -m "feat: add notarize.sh for Developer ID signing and Apple notarization"
```

注意：此脚本需要配置凭证后才能测试。首次配置凭证方法：

```bash
xcrun notarytool store-credentials "FluxQ-notarize" \
  --apple-id "your@email.com" \
  --team-id "XXXXXXXXXX" \
  --password "app-specific-password"
```

---

### Task 3: build-dmg.sh — 入口编排脚本

Aggregate Target 调用的顶层脚本，编排完整流程。

**Files:**
- Create: `scripts/build-dmg.sh`

**Step 1: 创建脚本**

创建 `scripts/build-dmg.sh`：

```bash
#!/bin/bash
set -euo pipefail

# 此脚本由 Xcode Aggregate Target "FluxQ DMG" 的 Run Script Phase 调用
# 也可独立使用: ./scripts/build-dmg.sh [path-to-app] [output-dir]

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
APP_PATH="${1:-${BUILT_PRODUCTS_DIR:-build}/FluxQ.app}"
OUTPUT_DIR="${2:-${SCRIPT_DIR}/../build}"

if [ ! -d "$APP_PATH" ]; then
  echo "Error: FluxQ.app not found at $APP_PATH"
  echo "Usage: build-dmg.sh [path-to-app] [output-dir]"
  exit 1
fi

echo "========================================"
echo "  FluxQ DMG Builder"
echo "========================================"
echo "App: $APP_PATH"
echo ""

# 签名 + 公证（设置 SKIP_NOTARIZE=1 可跳过）
if [ "${SKIP_NOTARIZE:-0}" != "1" ]; then
  echo "==> Step 1/2: 签名 + 公证"
  "$SCRIPT_DIR/notarize.sh" "$APP_PATH"
else
  echo "==> Step 1/2: 跳过签名公证 (SKIP_NOTARIZE=1)"
fi

# 打包 DMG
echo "==> Step 2/2: 打包 DMG"
"$SCRIPT_DIR/create-dmg.sh" "$APP_PATH" "$OUTPUT_DIR"

echo "========================================"
echo "  完成！"
echo "========================================"
```

**Step 2: 赋予执行权限**

Run: `chmod +x scripts/build-dmg.sh`

**Step 3: 验证跳过公证模式**

Run: `SKIP_NOTARIZE=1 ./scripts/build-dmg.sh /tmp/FluxQ-test-build/FluxQ.app /tmp/FluxQ-test-build`
Expected: "跳过签名公证" + "DMG 已生成"

**Step 4: Commit**

```bash
git add scripts/build-dmg.sh
git commit -m "feat: add build-dmg.sh orchestrator for Xcode Aggregate Target"
```

---

### Task 4: 添加 Xcode Aggregate Target + Scheme

在 Xcode 项目中创建 Aggregate Target 和对应 Scheme。

**Files:**
- Modify: `FluxQ.xcodeproj/project.pbxproj`

**Step 1: 在 Xcode 中添加 Aggregate Target**

这一步需要在 Xcode 中手动操作：

1. 打开 `FluxQ.xcodeproj`
2. File → New → Target
3. 选择 **Other** → **Aggregate**
4. Product Name: `FluxQ DMG`
5. 点击 Finish

**Step 2: 配置 Target Dependency**

1. 选中 `FluxQ DMG` target
2. Build Phases → Target Dependencies → 点击 `+`
3. 添加 `FluxQ` app target

**Step 3: 添加 Run Script Phase**

1. Build Phases → 点击 `+` → New Run Script Phase
2. Shell: `/bin/bash`
3. 脚本内容：

```bash
"${SRCROOT}/scripts/build-dmg.sh"
```

4. 取消勾选 "Based on dependency analysis"（确保每次都运行）

**Step 4: 配置 Scheme**

1. Xcode 应已自动创建 `FluxQ DMG` scheme
2. Edit Scheme → Build → Build Configuration 改为 **Release**
3. 确认 `FluxQ DMG` target 在 build list 中

**Step 5: 将 `build/` 添加到 .gitignore**

修改 `.gitignore`，追加：

```
# DMG build output
build/
```

**Step 6: Commit**

```bash
git add FluxQ.xcodeproj/project.pbxproj .gitignore
git commit -m "feat: add FluxQ DMG Aggregate Target and scheme"
```

---

### Task 5: 端到端验证

**Step 1: 跳过公证的快速测试**

1. Xcode 选择 `FluxQ DMG` scheme
2. 设置环境变量：Edit Scheme → Run → Arguments → Environment Variables → `SKIP_NOTARIZE = 1`
3. ⌘B 构建
4. 检查 `build/FluxQ-*.dmg` 是否生成

**Step 2: 验证 DMG 内容**

Run: `hdiutil attach build/FluxQ-*.dmg`
Expected: 挂载成功，包含 FluxQ.app 和 Applications 快捷方式

Run: `hdiutil detach /Volumes/FluxQ`

**Step 3: 完整流程测试（需要凭证）**

配置完凭证后：
1. 移除 `SKIP_NOTARIZE` 环境变量
2. 设置 `DEVELOPER_ID_NAME` 和 `NOTARIZE_KEYCHAIN_PROFILE` 环境变量
3. ⌘B 构建
4. 验证 DMG 中的 .app 通过 Gatekeeper: `spctl --assess --type execute build/FluxQ.app`

---

## 文件变更总览

| 操作 | 文件路径 |
|------|----------|
| **新建** | `scripts/create-dmg.sh` |
| **新建** | `scripts/notarize.sh` |
| **新建** | `scripts/build-dmg.sh` |
| 修改 | `FluxQ.xcodeproj/project.pbxproj` |
| 修改 | `.gitignore` |
